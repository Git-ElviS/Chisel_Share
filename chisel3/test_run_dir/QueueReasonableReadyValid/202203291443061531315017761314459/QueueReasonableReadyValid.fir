circuit QueueReasonableReadyValid :
  module Queue :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<3>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<3>}, count : UInt<3>}

    cmem ram : UInt<3> [4] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<2>, clock with :
      reset => (reset, UInt<2>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<2>, clock with :
      reset => (reset, UInt<2>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<2>("h3")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<2>("h3")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<3>("h4"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module MaxPeriodFibonacciLFSR :
    input clock : Clock
    input reset : Reset
    output io : { flip seed : { valid : UInt<1>, bits : UInt<1>[16]}, flip increment : UInt<1>, out : UInt<1>[16]}

    wire _state_WIRE : UInt<1>[16] @[PRNG.scala 46:28]
    _state_WIRE[0] <= UInt<1>("h1") @[PRNG.scala 46:28]
    _state_WIRE[1] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[2] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[3] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[4] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[5] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[6] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[7] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[8] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[9] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[10] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[11] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[12] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[13] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[14] <= UInt<1>("h0") @[PRNG.scala 46:28]
    _state_WIRE[15] <= UInt<1>("h0") @[PRNG.scala 46:28]
    reg state : UInt<1>[16], clock with :
      reset => (reset, _state_WIRE) @[PRNG.scala 55:49]
    when io.increment : @[PRNG.scala 69:22]
      node _T = xor(state[15], state[13]) @[LFSR.scala 15:41]
      node _T_1 = xor(_T, state[12]) @[LFSR.scala 15:41]
      node _T_2 = xor(_T_1, state[10]) @[LFSR.scala 15:41]
      state[0] <= _T_2 @[PRNG.scala 70:11]
      state[1] <= state[0] @[PRNG.scala 70:11]
      state[2] <= state[1] @[PRNG.scala 70:11]
      state[3] <= state[2] @[PRNG.scala 70:11]
      state[4] <= state[3] @[PRNG.scala 70:11]
      state[5] <= state[4] @[PRNG.scala 70:11]
      state[6] <= state[5] @[PRNG.scala 70:11]
      state[7] <= state[6] @[PRNG.scala 70:11]
      state[8] <= state[7] @[PRNG.scala 70:11]
      state[9] <= state[8] @[PRNG.scala 70:11]
      state[10] <= state[9] @[PRNG.scala 70:11]
      state[11] <= state[10] @[PRNG.scala 70:11]
      state[12] <= state[11] @[PRNG.scala 70:11]
      state[13] <= state[12] @[PRNG.scala 70:11]
      state[14] <= state[13] @[PRNG.scala 70:11]
      state[15] <= state[14] @[PRNG.scala 70:11]
    when io.seed.valid : @[PRNG.scala 73:22]
      state[0] <= io.seed.bits[0] @[PRNG.scala 74:11]
      state[1] <= io.seed.bits[1] @[PRNG.scala 74:11]
      state[2] <= io.seed.bits[2] @[PRNG.scala 74:11]
      state[3] <= io.seed.bits[3] @[PRNG.scala 74:11]
      state[4] <= io.seed.bits[4] @[PRNG.scala 74:11]
      state[5] <= io.seed.bits[5] @[PRNG.scala 74:11]
      state[6] <= io.seed.bits[6] @[PRNG.scala 74:11]
      state[7] <= io.seed.bits[7] @[PRNG.scala 74:11]
      state[8] <= io.seed.bits[8] @[PRNG.scala 74:11]
      state[9] <= io.seed.bits[9] @[PRNG.scala 74:11]
      state[10] <= io.seed.bits[10] @[PRNG.scala 74:11]
      state[11] <= io.seed.bits[11] @[PRNG.scala 74:11]
      state[12] <= io.seed.bits[12] @[PRNG.scala 74:11]
      state[13] <= io.seed.bits[13] @[PRNG.scala 74:11]
      state[14] <= io.seed.bits[14] @[PRNG.scala 74:11]
      state[15] <= io.seed.bits[15] @[PRNG.scala 74:11]
    io.out <= state @[PRNG.scala 78:10]

  module QueueReasonableReadyValid :
    input clock : Clock
    input reset : UInt<1>
    output io : { }

    inst q of Queue @[QueueSpec.scala 46:17]
    q.clock <= clock
    q.reset <= reset
    wire elems : UInt<3>[20] @[QueueSpec.scala 47:22]
    elems[0] <= UInt<3>("h7") @[QueueSpec.scala 47:22]
    elems[1] <= UInt<1>("h0") @[QueueSpec.scala 47:22]
    elems[2] <= UInt<2>("h2") @[QueueSpec.scala 47:22]
    elems[3] <= UInt<3>("h4") @[QueueSpec.scala 47:22]
    elems[4] <= UInt<1>("h1") @[QueueSpec.scala 47:22]
    elems[5] <= UInt<3>("h5") @[QueueSpec.scala 47:22]
    elems[6] <= UInt<3>("h7") @[QueueSpec.scala 47:22]
    elems[7] <= UInt<2>("h2") @[QueueSpec.scala 47:22]
    elems[8] <= UInt<1>("h1") @[QueueSpec.scala 47:22]
    elems[9] <= UInt<3>("h7") @[QueueSpec.scala 47:22]
    elems[10] <= UInt<1>("h0") @[QueueSpec.scala 47:22]
    elems[11] <= UInt<3>("h4") @[QueueSpec.scala 47:22]
    elems[12] <= UInt<3>("h4") @[QueueSpec.scala 47:22]
    elems[13] <= UInt<3>("h6") @[QueueSpec.scala 47:22]
    elems[14] <= UInt<2>("h2") @[QueueSpec.scala 47:22]
    elems[15] <= UInt<1>("h1") @[QueueSpec.scala 47:22]
    elems[16] <= UInt<2>("h2") @[QueueSpec.scala 47:22]
    elems[17] <= UInt<1>("h1") @[QueueSpec.scala 47:22]
    elems[18] <= UInt<3>("h4") @[QueueSpec.scala 47:22]
    elems[19] <= UInt<2>("h2") @[QueueSpec.scala 47:22]
    reg value : UInt<5>, clock with :
      reset => (reset, UInt<5>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<5>, clock with :
      reset => (reset, UInt<5>("h0")) @[Counter.scala 62:40]
    node _q_io_enq_valid_T = lt(value, UInt<5>("h14")) @[QueueSpec.scala 53:34]
    q.io.enq.valid <= _q_io_enq_valid_T @[QueueSpec.scala 53:18]
    node _T = eq(q.io.count, UInt<3>("h4")) @[QueueSpec.scala 55:39]
    node _T_1 = or(q.io.enq.ready, _T) @[QueueSpec.scala 55:25]
    node _T_2 = bits(reset, 0, 0) @[QueueSpec.scala 55:9]
    node _T_3 = eq(_T_2, UInt<1>("h0")) @[QueueSpec.scala 55:9]
    when _T_3 : @[QueueSpec.scala 55:9]
      assert(clock, _T_1, UInt<1>("h1"), "") : assert @[QueueSpec.scala 55:9]
      node _T_4 = eq(_T_1, UInt<1>("h0")) @[QueueSpec.scala 55:9]
      when _T_4 : @[QueueSpec.scala 55:9]
        printf(clock, UInt<1>("h1"), "Assertion failed\n    at QueueSpec.scala:55 assert(q.io.enq.ready || q.io.count === queueDepth.U)\n") : printf @[QueueSpec.scala 55:9]
    inst q_io_deq_ready_prng of MaxPeriodFibonacciLFSR @[PRNG.scala 91:22]
    q_io_deq_ready_prng.clock <= clock
    q_io_deq_ready_prng.reset <= reset
    q_io_deq_ready_prng.io.seed.valid <= UInt<1>("h0") @[PRNG.scala 92:24]
    q_io_deq_ready_prng.io.seed.bits[0] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[1] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[2] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[3] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[4] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[5] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[6] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[7] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[8] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[9] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[10] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[11] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[12] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[13] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[14] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.seed.bits[15] is invalid @[PRNG.scala 93:23]
    q_io_deq_ready_prng.io.increment <= UInt<1>("h1") @[PRNG.scala 94:23]
    node q_io_deq_ready_lo_lo_lo = cat(q_io_deq_ready_prng.io.out[1], q_io_deq_ready_prng.io.out[0]) @[PRNG.scala 95:17]
    node q_io_deq_ready_lo_lo_hi = cat(q_io_deq_ready_prng.io.out[3], q_io_deq_ready_prng.io.out[2]) @[PRNG.scala 95:17]
    node q_io_deq_ready_lo_lo = cat(q_io_deq_ready_lo_lo_hi, q_io_deq_ready_lo_lo_lo) @[PRNG.scala 95:17]
    node q_io_deq_ready_lo_hi_lo = cat(q_io_deq_ready_prng.io.out[5], q_io_deq_ready_prng.io.out[4]) @[PRNG.scala 95:17]
    node q_io_deq_ready_lo_hi_hi = cat(q_io_deq_ready_prng.io.out[7], q_io_deq_ready_prng.io.out[6]) @[PRNG.scala 95:17]
    node q_io_deq_ready_lo_hi = cat(q_io_deq_ready_lo_hi_hi, q_io_deq_ready_lo_hi_lo) @[PRNG.scala 95:17]
    node q_io_deq_ready_lo = cat(q_io_deq_ready_lo_hi, q_io_deq_ready_lo_lo) @[PRNG.scala 95:17]
    node q_io_deq_ready_hi_lo_lo = cat(q_io_deq_ready_prng.io.out[9], q_io_deq_ready_prng.io.out[8]) @[PRNG.scala 95:17]
    node q_io_deq_ready_hi_lo_hi = cat(q_io_deq_ready_prng.io.out[11], q_io_deq_ready_prng.io.out[10]) @[PRNG.scala 95:17]
    node q_io_deq_ready_hi_lo = cat(q_io_deq_ready_hi_lo_hi, q_io_deq_ready_hi_lo_lo) @[PRNG.scala 95:17]
    node q_io_deq_ready_hi_hi_lo = cat(q_io_deq_ready_prng.io.out[13], q_io_deq_ready_prng.io.out[12]) @[PRNG.scala 95:17]
    node q_io_deq_ready_hi_hi_hi = cat(q_io_deq_ready_prng.io.out[15], q_io_deq_ready_prng.io.out[14]) @[PRNG.scala 95:17]
    node q_io_deq_ready_hi_hi = cat(q_io_deq_ready_hi_hi_hi, q_io_deq_ready_hi_hi_lo) @[PRNG.scala 95:17]
    node q_io_deq_ready_hi = cat(q_io_deq_ready_hi_hi, q_io_deq_ready_hi_lo) @[PRNG.scala 95:17]
    node _q_io_deq_ready_T = cat(q_io_deq_ready_hi, q_io_deq_ready_lo) @[PRNG.scala 95:17]
    node _q_io_deq_ready_T_1 = bits(_q_io_deq_ready_T, 0, 0) @[QueueSpec.scala 57:29]
    q.io.deq.ready <= _q_io_deq_ready_T_1 @[QueueSpec.scala 57:18]
    node _T_5 = eq(q.io.count, UInt<1>("h0")) @[QueueSpec.scala 59:39]
    node _T_6 = or(q.io.deq.valid, _T_5) @[QueueSpec.scala 59:25]
    node _T_7 = bits(reset, 0, 0) @[QueueSpec.scala 59:9]
    node _T_8 = eq(_T_7, UInt<1>("h0")) @[QueueSpec.scala 59:9]
    when _T_8 : @[QueueSpec.scala 59:9]
      assert(clock, _T_6, UInt<1>("h1"), "") : assert_1 @[QueueSpec.scala 59:9]
      node _T_9 = eq(_T_6, UInt<1>("h0")) @[QueueSpec.scala 59:9]
      when _T_9 : @[QueueSpec.scala 59:9]
        printf(clock, UInt<1>("h1"), "Assertion failed\n    at QueueSpec.scala:59 assert(q.io.deq.valid || q.io.count === 0.U)\n") : printf_1 @[QueueSpec.scala 59:9]
    q.io.enq.bits <= elems[value] @[QueueSpec.scala 61:17]
    node _T_10 = and(q.io.enq.ready, q.io.enq.valid) @[Decoupled.scala 50:35]
    when _T_10 : @[QueueSpec.scala 62:23]
      node wrap = eq(value, UInt<5>("h14")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
      when wrap : @[Counter.scala 88:20]
        value <= UInt<1>("h0") @[Counter.scala 88:28]
    node _T_11 = and(q.io.deq.ready, q.io.deq.valid) @[Decoupled.scala 50:35]
    when _T_11 : @[QueueSpec.scala 65:23]
      node wrap_1 = eq(value_1, UInt<5>("h14")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
      when wrap_1 : @[Counter.scala 88:20]
        value_1 <= UInt<1>("h0") @[Counter.scala 88:28]
    node _T_12 = eq(value_1, UInt<5>("h14")) @[QueueSpec.scala 68:21]
    when _T_12 : @[QueueSpec.scala 68:44]
      node _T_13 = bits(reset, 0, 0) @[QueueSpec.scala 69:9]
      node _T_14 = eq(_T_13, UInt<1>("h0")) @[QueueSpec.scala 69:9]
      when _T_14 : @[QueueSpec.scala 69:9]
        stop(clock, UInt<1>("h1"), 0) : stop @[QueueSpec.scala 69:9]
